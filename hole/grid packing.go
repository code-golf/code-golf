package hole

import (
	"strconv"
	"strings"
)

type GridTestCase struct {
	width int
	boxes []GridBox
}

type GridBox struct {
	width  int
	height int
}

type GridBoxSolution struct {
	x int
	y int
}

type (
	GridSolution []GridBoxSolution
)

func formatGridSolution(solution GridSolution) string {
	var sb strings.Builder

	for i, box := range solution {
		sb.WriteString(strconv.Itoa(box.x))
		sb.WriteRune(' ')
		sb.WriteString(strconv.Itoa(box.y))

		if i < len(solution)-1 {
			sb.WriteRune(' ')
		}
	}

	return sb.String()
}

func parseInt(k string) int {
	out, err := strconv.Atoi(k)
	if err != nil {
		panic(err)
	}
	return out
}

func parseGridQuestion(data string) GridTestCase {
	parts := strings.Split(data, " ")

	boxes := make([]GridBox, 0)
	for i := range (len(parts) - 1) / 2 {
		boxes = append(boxes, GridBox{
			width:  parseInt(parts[i*2+1]),
			height: parseInt(parts[i*2+2]),
		})
	}

	return GridTestCase{
		width: parseInt(parts[0]),
		boxes: boxes,
	}
}

func formatGridQuestion(board GridTestCase) string {
	var sb strings.Builder

	sb.WriteString(strconv.Itoa(board.width))
	sb.WriteRune(' ')

	for i, box := range board.boxes {
		sb.WriteString(strconv.Itoa(box.width))
		sb.WriteRune(' ')
		sb.WriteString(strconv.Itoa(box.height))
		if i < len(board.boxes)-1 {
			sb.WriteRune(' ')
		}
	}

	return sb.String()
}

func All[T any](ts []T, pred func(T) bool) bool {
	for _, t := range ts {
		if !pred(t) {
			return false
		}
	}
	return true
}

func solveGrid(question GridTestCase) GridSolution {
	heights := make([]int, question.width)
	var solution GridSolution
	x := 0
	y := 0

	for _, box := range question.boxes {
		for x+box.width > question.width || !All(heights[x:x+box.width], (func(k int) bool { return k <= y })) {
			x++
			if x+box.width > question.width {
				x = 0
				y++
			}
		}

		for i := range box.width {
			heights[i+x] = y + box.height
		}
		solution = append(solution, GridBoxSolution{x, y})
		x += box.width
	}

	return solution
}

func getGridStaticTestCases() (grids []GridTestCase) {
	for _, test := range fixedTests("grid-packing") {
		grids = append(grids, parseGridQuestion(test.in))
	}

	return shuffle(grids)
}

func genGridTestCase() GridTestCase {
	width := randInt(1, 15)
	boxes := make([]GridBox, 0)

	for range randInt(5, 45) {
		boxes = append(boxes,
			GridBox{
				width:  min(randInt(1, width), randInt(1, width)),
				height: min(randInt(1, 10), randInt(1, 10)),
			})
	}

	return GridTestCase{
		width,
		boxes,
	}
}

func getGridAutogeneratedTestCases() (grids []GridTestCase) {
	const runs = 20

	for range runs {
		grid := genGridTestCase()
		grids = append(grids, grid)
	}

	return grids
}

func gridPacking() []Run {
	runs := make([]Run, 2)

	testCases := [][]GridTestCase{
		getGridAutogeneratedTestCases(),
		getGridStaticTestCases(),
	}

	for i, board := range testCases {
		args := make([]string, len(board))
		answer := make([]string, len(board))
		for j, grid := range board {
			args[j] = formatGridQuestion(grid)
			answer[j] = formatGridSolution(solveGrid(grid))
		}

		runs[i] = Run{Args: args, Answer: strings.Join(answer, "\n")}
	}

	return runs
}
