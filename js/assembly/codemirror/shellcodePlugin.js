import { StateField, RangeSet, RangeSetBuilder }  from '@codemirror/state';
import { ASMStateField, ASMColorFacet, ASMColor } from './compilerPlugin.js';

/**
 * @typedef {Object} ShellcodeState
 * @property {RangeSet<ASMColor>} colors Invalid or extended UTF-8 sequences
 * @property {String} code The shellcode generated by the assembly dumps
 */

/**
 * @param {Uint8Array} bytes 
 * @returns {ShellcodeState}
 */
function getShellcode(bytes)
{
    let uniSeqLen = 0, uniSeqStart = -1;
    let code = "";
    /** @type {RangeSetBuilder<ASMColor>} */
    let builder = new RangeSetBuilder();

    for(let i = 0; true; i++)
    {
        let byte = bytes[i] ?? 0;
        try {
            if(byte < 0x80)
            {
                if(uniSeqStart >= 0)
                    throw [uniSeqStart, i];
            }
            else if(byte < 0xC0)
            {
                if(uniSeqStart < 0)
                    throw [i, i + 1];

                if(i - uniSeqStart == uniSeqLen)
                {
                    try {
                        let uriSeq = "";
                        for(let j = uniSeqStart; j <= i; j++)
                            uriSeq += '%' + bytes[j].toString(16);
                        code += decodeURIComponent(uriSeq);
                    }
                    catch(e) {
                        throw [uniSeqStart, i + 1];
                    }
                    builder.add(uniSeqStart, i + 1, new ASMColor("#00F"));
                    uniSeqStart = -1;
                }
            }
            else
            {
                if(uniSeqStart >= 0)
                    throw [uniSeqStart, i];
            }
        } catch([from, to]) {
            builder.add(from, to, new ASMColor("#F00"));
            for(let i = from; i < to; i++)
                code += '\\' + bytes[i].toString(8);
            uniSeqStart = -1;
        }

        if(i == bytes.length)
            break;

        if(byte < 0x80)
        {
            let char;
            if(byte == 0)
                char = '\\0';
            else if(byte == 13)
                char = '\\15';
            else
            {
                char = String.fromCharCode(byte);
                if(char == '\\' || char == '"')
                    char = '\\' + char;
            }
            code += char;
        }
        else if(byte >= 0xC0)
        {
            uniSeqStart = i;
            uniSeqLen = (byte < 0xE0 ? 1 :
                         byte < 0xF0 ? 2 : 3);
        }
    }
    return { code, colors: builder.finish() };
}

/** @type {StateField<ShellcodeState>} */
export const ShellcodeField = StateField.define({
    create: state => {
        return getShellcode(state.field(ASMStateField).head.dump());
    },
    update: (state, transaction) => {
        if(!transaction.docChanged)
            return state;

        return getShellcode(transaction.state.field(ASMStateField).head.dump());
    }
});

const ShellcodeColors = ASMColorFacet.compute(
    [ShellcodeField],
    state => state.field(ShellcodeField).colors
);

export const ShellcodePlugin = [ShellcodeField.extension, ShellcodeColors];